#include "todo_service.hpp"
#include <algorithm>

#include <drogon/drogon.h>


std::vector<TodoEntity>& TodoService::get_todos()
{
    auto dbClient = drogon::app().getDbClient();
    if (!dbClient)
    {
        LOG_ERROR << "DBClient not found!";
    }
    else
    {
        dbClient->execSqlAsync(
    "SELECT version();",
    [](const drogon::orm::Result &result) {
        for (const auto &row : result) {
            std::string version = row[0].as<std::string>();
            std::cout << "PostgreSQL version: " << version << std::endl;
        }
    },
    [](const drogon::orm::DrogonDbException &e) {
        std::cerr << "Database error: " << e.base().what() << std::endl;
    });

    }
    return m_todos;
}

std::optional<TodoEntity> TodoService::get_todo_by_id(int id)
{
    const auto it = std::ranges::find_if(m_todos, [id](const TodoEntity& entity)
    {
        return entity.id == id;
    });

    if (it == std::end(m_todos))
    {
        return std::nullopt;
    }
    return *it;
}

TodoEntity TodoService::create_todo(const std::string& title, const std::string& description)
{
    static int iid = 100; // TODO: this id will be generated by server and will not provided by client
    //TODO: in the future id parameter will not provided and will generated and store in DB.
    const TodoEntity entity{
        .id = iid,
        .title = title,
        .description = description,
        .completed = false,
        .created_at = std::chrono::system_clock::now()
    };
    ++iid;
    m_todos.push_back(entity);
    return entity;
}

std::optional<TodoEntity> TodoService::update_todo_by_id(int id, const std::optional<std::string>& title, const std::optional<std::string>& description, const std::optional<bool>& completed)
{
    const auto it = std::ranges::find_if(m_todos, [id](const TodoEntity& entity)
    {
        return entity.id == id;
    });

    if (it == std::end(m_todos))
    {
        return std::nullopt;
    }

    it->title = title.value_or(it->title);
    it->description = description.value_or(it->description);
    it->completed = completed.value_or(it->completed);
    return *it;
}

std::optional<TodoEntity> TodoService::delete_todo_by_id(int id)
{
    const auto it = std::ranges::find_if(m_todos, [id](const TodoEntity& entity)
    {
        return entity.id == id;
    });

    if (it == std::end(m_todos))
    {
        return std::nullopt;
    }

    auto value = *it;
    m_todos.erase(it);
    return value;
}

void TodoService::create_dummy_data_for_test()
{
    m_todos.emplace_back(0, "Note N0", "Description 0", false, std::chrono::system_clock::now());
    m_todos.emplace_back(1, "Note N1", "Description 1", true, std::chrono::system_clock::now());
    m_todos.emplace_back(2, "Note N2", "Description 2", false, std::chrono::system_clock::now());
    m_todos.emplace_back(3, "Note N3", "Description 3", true, std::chrono::system_clock::now());
    m_todos.emplace_back(4, "Note N4", "Description 4", true, std::chrono::system_clock::now());
}
